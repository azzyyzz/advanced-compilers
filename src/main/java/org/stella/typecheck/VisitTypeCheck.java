// File generated by the BNF Converter (bnfc 2.9.5).
package org.stella.typecheck;

import java.util.HashMap;
import java.util.HashSet;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.syntax.stella.Absyn.*;
import org.syntax.stella.Absyn.Record;

/**
 * * Visitor Design Pattern Skeleton. **
 */

/*
 * This implements the common visitor design pattern.
 * Tests show it to be slightly less efficient than the
 * instanceof method, but easier to use.
 * Replace the R and A parameters with the desired return
 * and context types.
 */
public class VisitTypeCheck {

    BidirectionalCheck checker = new BidirectionalCheck();
    // Unification unif = new Unification();
    boolean hasMain = false;

    public class ProgramVisitor implements Program.Visitor<Void, Void> {

        @Override
        public Void visit(AProgram p, Void arg) {
            /* Code for AProgram goes here */
            // p.languagedecl_.accept(new LanguageDeclVisitor<R, A>(), arg);
            Context context = new Context(new HashMap<>(), new HashSet<>(), null, null);
            for (Extension x : p.listextension_) {
                x.accept(new ExtensionVisitor(), context);
            }

            if (context.extensions.contains("#structural-subtyping")) {
                checker.subtyping = true;
            }
            if (context.extensions.contains("#ambiguous-type-as-bottom")) {
                checker.ambiguousType = true;
            }
            if (context.extensions.contains("#type-reconstruction")) {
                // unif.recon = true;
                checker.recon = true;
            }

            for (Decl x : p.listdecl_) {
                if (x instanceof DeclFun declFun) {
                    if (declFun.stellaident_.equals("main")) {
                        hasMain = true;
                        if (declFun.listparamdecl_.size() != 1) {
                            throw new IllegalArgumentException("[ERROR_INCORRECT_ARITY_OF_MAIN]");
                        }
                    }
                    // System.out.println("-------> " + declFun.stellaident_);
                    ListType params = new ListType();
                    for (ParamDecl y : declFun.listparamdecl_) {
                        Type type = y.accept(new ParamDeclVisitor(), context.newScope());
                        params.add(type);
                    }
                    context.variables.put(declFun.stellaident_, new TypeFun(params,
                            declFun.returntype_.accept(new ReturnTypeVisitor(), context.newScope())));
                }
            }

            for (Decl x : p.listdecl_) {
                x.accept(new DeclVisitor(), context);
            }
            if (!hasMain) {
                throw new IllegalArgumentException("[ERROR_MISSING_MAIN]");
            }
            System.exit(0);
            return null;
        }
    }

    public class LanguageDeclVisitor<R, A> implements LanguageDecl.Visitor<R, A> {

        @Override
        public R visit(LanguageCore p, A arg) {
            /* Code for LanguageCore goes here */
            return null;
        }
    }

    public class ExtensionVisitor implements Extension.Visitor<Void, Context> {

        @Override
        public Void visit(AnExtension p, Context arg) {
            /* Code for AnExtension goes here */
            for (String x : p.listextensionname_) {
                // x;
                arg.extensions.add(x);
            }
            return null;
        }
    }

    public class DeclVisitor implements Decl.Visitor<Void, Context> {

        @Override
        public Void visit(DeclFun p, Context arg) {
            /* Code for DeclFun goes here */
            // for (Annotation x : p.listannotation_) {
            // x.accept(new AnnotationVisitor(), arg);
            // }
            // p.stellaident_;
            System.out.println("DeclFun " + p.stellaident_);

            for (ParamDecl x : p.listparamdecl_) {
                x.accept(new ParamDeclVisitor(), arg);
            }
            Type returnType = p.returntype_.accept(new ReturnTypeVisitor(), arg.newScope());
            Type exprType = p.expr_.accept(new ExprVisitor(), arg.newScope());

            // for (Decl x : p.listdecl_) {
            // x.accept(new DeclVisitor(), arg);
            // }
            System.out.println(returnType.getClass() + " " + exprType.getClass());
            checker.check(returnType, exprType);
            System.out.println("DeclFun out");
            return null;
        }

        @Override
        public Void visit(DeclFunGeneric p, Context arg) {
            /* Code for DeclFunGeneric goes here */
            // for (Annotation x : p.listannotation_) {
            // x.accept(new AnnotationVisitor<R, A>(), arg);
            // }
            // //p.stellaident_;
            // for (String x : p.liststellaident_) {
            // //x;
            // }
            // for (ParamDecl x : p.listparamdecl_) {
            // x.accept(new ParamDeclVisitor<R, A>(), arg);
            // }
            // p.returntype_.accept(new ReturnTypeVisitor<R, A>(), arg);
            // p.throwtype_.accept(new ThrowTypeVisitor<R, A>(), arg);
            // for (Decl x : p.listdecl_) {
            // x.accept(new DeclVisitor<R, A>(), arg);
            // }
            // p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Void visit(DeclTypeAlias p, Context arg) {
            /* Code for DeclTypeAlias goes here */
            // p.stellaident_;
            // p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Void visit(DeclExceptionType p, Context arg) {
            /* Code for DeclExceptionType goes here */
            // p.type_.accept(new TypeVisitor<R, A>(), arg);
            arg.exceptionType = p.type_;
            return null;
        }

        @Override
        public Void visit(DeclExceptionVariant p, Context arg) {
            /* Code for DeclExceptionVariant goes here */
            // p.stellaident_;
            // p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }
    }

    public class LocalDeclVisitor<R, A> implements LocalDecl.Visitor<R, A> {

        @Override
        public R visit(ALocalDecl p, A arg) {
            /* Code for ALocalDecl goes here */
            // p.decl_.accept(new DeclVisitor<R, A>(), arg);
            return null;
        }
    }

    public class AnnotationVisitor<R, A> implements Annotation.Visitor<R, A> {

        @Override
        public R visit(InlineAnnotation p, A arg) {
            /* Code for InlineAnnotation goes here */
            return null;
        }
    }

    public class ParamDeclVisitor implements ParamDecl.Visitor<Type, Context> {

        @Override
        public Type visit(AParamDecl p, Context arg) {
            /* Code for AParamDecl goes here */
            // p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            arg.variables.put(p.stellaident_, p.type_);
            return p.type_;
        }
    }

    public class ReturnTypeVisitor implements ReturnType.Visitor<Type, Context> {

        @Override
        public Type visit(NoReturnType p, Context arg) {
            /* Code for NoReturnType goes here */
            return null;
        }

        @Override
        public Type visit(SomeReturnType p, Context arg) {
            /* Code for SomeReturnType goes here */
            // p.type_.accept(new TypeVisitor(), arg);
            System.out.println("SomeReturnType\n");
            return p.type_;
        }
    }

    public class ThrowTypeVisitor<R, A> implements ThrowType.Visitor<R, A> {

        @Override
        public R visit(NoThrowType p, A arg) {
            /* Code for NoThrowType goes here */
            return null;
        }

        @Override
        public R visit(SomeThrowType p, A arg) {
            /* Code for SomeThrowType goes here */
            // for (Type x : p.listtype_) {
            // x.accept(new TypeVisitor(), arg);
            // }
            return null;
        }
    }

    public class TypeVisitor implements Type.Visitor<Type, Context> {

        @Override
        public Type visit(TypeAuto p, Context arg) {
            /* Code for TypeAuto goes here */
            return null;
        }

        @Override
        public Type visit(TypeFun p, Context arg) {
            /* Code for TypeFun goes here */
            for (Type x : p.listtype_) {
                x.accept(new TypeVisitor(), arg);
            }
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(TypeForAll p, Context arg) {
            /* Code for TypeForAll goes here */
            for (String x : p.liststellaident_) {
                // x;
            }
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(TypeRec p, Context arg) {
            /* Code for TypeRec goes here */
            // p.stellaident_;
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(TypeSum p, Context arg) {
            /* Code for TypeSum goes here */
            System.out.println("TypeSum");
            p.type_1.accept(new TypeVisitor(), arg);
            p.type_2.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(TypeTuple p, Context arg) {
            /* Code for TypeTuple goes here */
            for (Type x : p.listtype_) {
                x.accept(new TypeVisitor(), arg);
            }
            return null;
        }

        @Override
        public Type visit(TypeRecord p, Context arg) {
            /* Code for TypeRecord goes here */
            // for (RecordFieldType x : p.listrecordfieldtype_) {
            // x.accept(new RecordFieldTypeVisitor<R, A>(), arg);
            // }
            return null;
        }

        @Override
        public Type visit(TypeVariant p, Context arg) {
            /* Code for TypeVariant goes here */
            // for (VariantFieldType x : p.listvariantfieldtype_) {
            // x.accept(new VariantFieldTypeVisitor<R, A>(), arg);
            // }
            return null;
        }

        @Override
        public Type visit(TypeList p, Context arg) {
            /* Code for TypeList goes here */
            p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(TypeBool p, Context arg) {
            /* Code for TypeBool goes here */
            return null;
        }

        @Override
        public Type visit(TypeNat p, Context arg) {
            /* Code for TypeNat goes here */
            return null;
        }

        @Override
        public Type visit(TypeUnit p, Context arg) {
            /* Code for TypeUnit goes here */
            return null;
        }

        @Override
        public Type visit(TypeTop p, Context arg) {
            /* Code for TypeTop goes here */
            return null;
        }

        @Override
        public Type visit(TypeBottom p, Context arg) {
            /* Code for TypeBottom goes here */
            return null;
        }

        @Override
        public Type visit(TypeRef p, Context arg) {
            /* Code for TypeRef goes here */
            // p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public Type visit(TypeVar p, Context arg) {
            /* Code for TypeVar goes here */
            // p.stellaident_;
            // if (!arg.variables.containsKey(p.stellaident_)) {
            // throw new IllegalArgumentException("[ERROR_UNDEFINED_VARIABLE]");
            // }
            // return arg.variables.get(p.stellaident_);
            return null;
        }
    }

    public class MatchCaseVisitor implements MatchCase.Visitor<Pair<MatchCheck, Type>, Pair<Context, Type>> {

        @Override
        public Pair<MatchCheck, Type> visit(AMatchCase p, Pair<Context, Type> arg) {
            /* Code for AMatchCase goes here */
            MatchCheck match = p.pattern_.accept(new PatternVisitor(), arg);
            Type expr = p.expr_.accept(new ExprVisitor(), arg.getLeft());
            System.out.println("AMatchCase" + match.stellaident_);
            return Pair.of(match, expr);
        }
    }

    public class OptionalTypingVisitor implements OptionalTyping.Visitor<Type, Context> {

        @Override
        public Type visit(NoTyping p, Context arg) {
            /* Code for NoTyping goes here */
            return new TypeBottom();
        }

        @Override
        public Type visit(SomeTyping p, Context arg) {
            /* Code for SomeTyping goes here */
            // p.type_.accept(new TypeVisitor(), arg);
            return p.type_;
        }
    }

    // public class PatternDataVisitor implements PatternData.Visitor<Type, Context>
    // {

    // @Override
    // public Type visit(NoPatternData p, Context arg) {
    // /* Code for NoPatternData goes here */
    // return new TypeBottom();
    // }

    // @Override
    // public Type visit(SomePatternData p, Context arg) {
    // /* Code for SomePatternData goes here */
    // MatchCheck match = p.pattern_.accept(new PatternVisitor(), Pair.of(arg,
    // null));
    // return null;
    // }
    // }

    public class ExprDataVisitor implements ExprData.Visitor<Type, Context> {

        @Override
        public Type visit(NoExprData p, Context arg) {
            /* Code for NoExprData goes here */
            return new TypeBottom();
        }

        @Override
        public Type visit(SomeExprData p, Context arg) {
            /* Code for SomeExprData goes here */
            Type expr = p.expr_.accept(new ExprVisitor(), arg);
            return expr;
        }
    }

    public class PatternVisitor implements Pattern.Visitor<MatchCheck, Pair<Context, Type>> {

        @Override
        public MatchCheck visit(PatternCastAs p, Pair<Context, Type> arg) {
            /* Code for PatternCastAs goes here */
            System.out.println("PatternCastAs");
            p.pattern_.accept(new PatternVisitor(), arg);
            // p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public MatchCheck visit(PatternAsc p, Pair<Context, Type> arg) {
            /* Code for PatternAsc goes here */
            p.pattern_.accept(new PatternVisitor(), arg);
            // p.type_.accept(new TypeVisitor(), arg);
            return null;
        }

        @Override
        public MatchCheck visit(PatternVariant p, Pair<Context, Type> arg) {
            /* Code for PatternVariant goes here */
            // p.stellaident_;
            // p.patterndata_.accept(new PatternDataVisitor(), arg.getLeft());
            System.out.println("PatternVariant");
            if (!arg.getLeft().variantFields.containsKey(p.stellaident_)) {
                throw new IllegalArgumentException("[ERROR_UNEXPECTED_PATTERN_FOR_TYPE]");
            }
            MatchCheck matchRes = new MatchCheck();
            PatternVar pattern = (PatternVar) ((SomePatternData) p.patterndata_).pattern_;
            matchRes.matchVars.add(pattern.stellaident_);
            arg.getLeft().variables.put(pattern.stellaident_, arg.getLeft().variantFields.get(pattern.stellaident_));
            return matchRes;
        }

        @Override
        public MatchCheck visit(PatternInl p, Pair<Context, Type> arg) {
            /* Code for PatternInl goes here */
            System.out.println("PatternInl");
            if (arg.getRight() instanceof TypeSum argSum) {
                MatchCheck matchRes = new MatchCheck();
                boolean ambig = checker.ambiguousType;
                checker.ambiguousType = true;
                MatchCheck match = p.pattern_.accept(new PatternVisitor(), Pair.of(arg.getLeft(), argSum.type_1));
                checker.ambiguousType = ambig;
                matchRes.hasInl = true;
                matchRes.stellaident_ = match.stellaident_;
                return matchRes;
            }
            throw new IllegalArgumentException("[ERROR_UNEXPECTED_PATTERN_FOR_TYPE]");
        }

        @Override
        public MatchCheck visit(PatternInr p, Pair<Context, Type> arg) {
            /* Code for PatternInr goes here */
            System.out.println("PatternInr");
            if (arg.getRight() instanceof TypeSum argSum) {
                MatchCheck matchRes = new MatchCheck();
                boolean ambig = checker.ambiguousType;
                checker.ambiguousType = true;
                MatchCheck match = p.pattern_.accept(new PatternVisitor(), Pair.of(arg.getLeft(), argSum.type_2));
                checker.ambiguousType = ambig;
                matchRes.hasInr = true;
                matchRes.stellaident_ = match.stellaident_;
                return matchRes;
            }
            throw new IllegalArgumentException("[ERROR_UNEXPECTED_PATTERN_FOR_TYPE]");
        }

        @Override
        public MatchCheck visit(PatternTuple p, Pair<Context, Type> arg) {
            /* Code for PatternTuple goes here */
            for (Pattern x : p.listpattern_) {
                x.accept(new PatternVisitor(), arg);
            }
            return null;
        }

        @Override
        public MatchCheck visit(PatternRecord p, Pair<Context, Type> arg) {
            /* Code for PatternRecord goes here */
            for (LabelledPattern x : p.listlabelledpattern_) {
                x.accept(new LabelledPatternVisitor(), arg);
            }
            return null;
        }

        @Override
        public MatchCheck visit(PatternList p, Pair<Context, Type> arg) {
            /* Code for PatternList goes here */
            for (Pattern x : p.listpattern_) {
                x.accept(new PatternVisitor(), arg);
            }
            return null;
        }

        @Override
        public MatchCheck visit(PatternCons p, Pair<Context, Type> arg) {
            /* Code for PatternCons goes here */
            p.pattern_1.accept(new PatternVisitor(), arg);
            p.pattern_2.accept(new PatternVisitor(), arg);
            return null;
        }

        @Override
        public MatchCheck visit(PatternFalse p, Pair<Context, Type> arg) {
            /* Code for PatternFalse goes here */
            return null;
        }

        @Override
        public MatchCheck visit(PatternTrue p, Pair<Context, Type> arg) {
            /* Code for PatternTrue goes here */
            return null;
        }

        @Override
        public MatchCheck visit(PatternUnit p, Pair<Context, Type> arg) {
            /* Code for PatternUnit goes here */
            return null;
        }

        @Override
        public MatchCheck visit(PatternInt p, Pair<Context, Type> arg) {
            /* Code for PatternInt goes here */
            // p.integer_;
            return null;
        }

        @Override
        public MatchCheck visit(PatternSucc p, Pair<Context, Type> arg) {
            /* Code for PatternSucc goes here */
            // p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }

        @Override
        public MatchCheck visit(PatternVar p, Pair<Context, Type> arg) {
            /* Code for PatternVar goes here */
            // p.stellaident_;
            System.out.println("PatternVar " + p.stellaident_);
            // if (!(arg.getRight() instanceof TypeSum)) {
            // throw new IllegalArgumentException("[ERROR_UNEXPECTED_PATTERN_FOR_TYPE]");
            // }
            MatchCheck match = new MatchCheck();
            match.hasInl = true;
            match.hasInr = true;
            match.stellaident_ = p.stellaident_;
            arg.getLeft().variables.put(p.stellaident_, arg.getRight());
            return match;
        }
    }

    public class LabelledPatternVisitor<R, A> implements LabelledPattern.Visitor<R, A> {

        @Override
        public R visit(ALabelledPattern p, A arg) {
            /* Code for ALabelledPattern goes here */
            // p.stellaident_;
            // p.pattern_.accept(new PatternVisitor(), arg);
            return null;
        }
    }

    public class BindingVisitor implements Binding.Visitor<ARecordFieldType, Context> {

        @Override
        public ARecordFieldType visit(ABinding p, Context arg) {
            /* Code for ABinding goes here */
            // p.stellaident_;
            Type expr = p.expr_.accept(new ExprVisitor(), arg);
            return new ARecordFieldType(p.stellaident_, expr);
        }
    }

    public class ExprVisitor implements Expr.Visitor<Type, Context> {

        @Override
        public Type visit(Sequence p, Context arg) {
            /* Code for Sequence goes here */
            Type expr1 = p.expr_1.accept(new ExprVisitor(), arg);
            checker.check(new TypeUnit(), expr1);
            Type expr2 = p.expr_2.accept(new ExprVisitor(), arg);
            return expr2;
        }

        @Override
        public Type visit(Let p, Context arg) {
            /* Code for Let goes here */
            System.out.println("Let");
            for (PatternBinding x : p.listpatternbinding_) {
                x.accept(new PatternBindingVisitor(), arg);
            }
            Type expr = p.expr_.accept(new ExprVisitor(), arg.newScope());
            return expr;
        }

        @Override
        public Type visit(LetRec p, Context arg) {
            /* Code for LetRec goes here */
            for (PatternBinding x : p.listpatternbinding_) {
                x.accept(new PatternBindingVisitor(), arg);
            }
            // p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(TypeAbstraction p, Context arg) {
            /* Code for TypeAbstraction goes here */
            for (String x : p.liststellaident_) {
                // x;
            }
            // p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(Assign p, Context arg) {
            /* Code for Assign goes here */
            Type expr1 = p.expr_1.accept(new ExprVisitor(), arg);
            Type expr2 = p.expr_2.accept(new ExprVisitor(), arg);

            if (!(TypeRef.class.isInstance(expr1))) {
                throw new IllegalArgumentException("[ERROR_NOT_A_REFERENCE]");
            }
            TypeRef ref = (TypeRef) expr1;
            checker.check(ref.type_, expr2);
            return new TypeUnit();
        }

        @Override
        public Type visit(If p, Context arg) {
            /* Code for If goes here */
            // Type ifType = p.expr_1.accept(new ExprVisitor(), arg.newScope(new
            // TypeBool()));
            Type ifType = p.expr_1.accept(new ExprVisitor(), arg.newScope());
            Type thenType = p.expr_2.accept(new ExprVisitor(), arg.newScope());
            Type elseType = p.expr_3.accept(new ExprVisitor(), arg.newScope());

            checker.check(new TypeBool(), ifType);

            if (thenType instanceof TypeVariant thenVariant && elseType instanceof TypeVariant elseVariant) {
                ListVariantFieldType list = new ListVariantFieldType();

                list.addAll(Stream
                        .concat(thenVariant.listvariantfieldtype_.stream(), elseVariant.listvariantfieldtype_.stream())
                        .distinct().toList());

                return new TypeVariant(list);
            }
            checker.check(thenType, elseType);

            return thenType;
        }

        @Override
        public Type visit(LessThan p, Context arg) {
            /* Code for LessThan goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(LessThanOrEqual p, Context arg) {
            /* Code for LessThanOrEqual goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(GreaterThan p, Context arg) {
            /* Code for GreaterThan goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(GreaterThanOrEqual p, Context arg) {
            /* Code for GreaterThanOrEqual goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(Equal p, Context arg) {
            /* Code for Equal goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(NotEqual p, Context arg) {
            /* Code for NotEqual goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(TypeAsc p, Context arg) {
            /* Code for TypeAsc goes here */
            Type expr = p.expr_.accept(new ExprVisitor(), arg);
            // Type type = p.type_.accept(new TypeVisitor(), arg);
            return checker.check(p.type_, expr);
        }

        @Override
        public Type visit(TypeCast p, Context arg) {
            /* Code for TypeCast goes here */
            Type expr = p.expr_.accept(new ExprVisitor(), arg);
            // p.type_.accept(new TypeVisitor<R, A>(), arg);
            System.out.println("TypeCast");
            return checker.check(expr, p.type_);
        }

        @Override
        public Type visit(Abstraction p, Context arg) {
            /* Code for Abstraction goes here */
            // if (!(arg.expectedType instanceof TypeFun)) {
            // throw new IllegalArgumentException("[ERROR_UNEXPECTED_LAMBDA]");
            // }
            // TypeFun expected = (TypeFun) arg.expectedType;
            ListType list = new ListType();
            for (ParamDecl x : p.listparamdecl_) {
                Type param = x.accept(new ParamDeclVisitor(), arg);
                list.add(param);
            }
            Type returnType = p.expr_.accept(new ExprVisitor(), arg.newScope());

            if (returnType instanceof TypeSum returnSum && (!checker.ambiguousType
                    && (returnSum.type_1 instanceof TypeBottom || returnSum.type_2 instanceof TypeBottom))) {
                throw new IllegalArgumentException("[ERROR_AMBIGUOUS_SUM_TYPE]");
            }

            return new TypeFun(list, returnType);
        }

        @Override
        public Type visit(Variant p, Context arg) {
            /* Code for Variant goes here */
            // p.stellaident_;
            Type expr = p.exprdata_.accept(new ExprDataVisitor(), arg);
            ListVariantFieldType list = new ListVariantFieldType();
            // AVariantFieldType aVar =
            list.add(new AVariantFieldType(p.stellaident_, new SomeTyping(expr)));
            return new TypeVariant(list);
        }

        @Override
        public Type visit(Match p, Context arg) {
            /* Code for Match goes here */
            System.out.println("Match");
            Type expr = p.expr_.accept(new ExprVisitor(), arg);
            MatchCheck matchRes = new MatchCheck();
            Type retType = null;

            if (p.listmatchcase_.size() == 0) {
                throw new IllegalArgumentException("[ERROR_ILLEGAL_EMPTY_MATCHING]");
            }
            if (expr instanceof TypeVariant exprVariant) {
                arg.variantFields = exprVariant.listvariantfieldtype_.stream().map(AVariantFieldType.class::cast)
                        .collect(
                                Collectors.toMap(a -> a.stellaident_, a -> ((SomeTyping) a.optionaltyping_).type_));
            }
            for (MatchCase x : p.listmatchcase_) {
                Pair<MatchCheck, Type> match = x.accept(new MatchCaseVisitor(), Pair.of(arg, expr));
                matchRes.hasInl |= match.getLeft().hasInl;
                matchRes.hasInr |= match.getLeft().hasInr;
                if (retType == null) {
                    retType = match.getRight();
                } else {
                    retType = checker.check(match.getRight(), match.getRight());
                }
            }
            // System.out.println((matchRes.hasInl ? "true" : "false") + " " +
            // (matchRes.hasInl ? "true" : "false"));

            if (expr instanceof TypeVariant) {
                // if (matchRes.matchVars.isEmpty()) {
                // throw new IllegalArgumentException("[ERROR_ILLEGAL_EMPTY_MATCHING]");
                // }
                if (!matchRes.matchVars.containsAll(arg.variantFields.keySet())) {
                    throw new IllegalArgumentException("[ERROR_NONEXHAUSTIVE_MATCH_PATTERNS]");
                }
            }

            if (expr instanceof TypeSum) {
                if (!matchRes.hasInl || !matchRes.hasInr) {
                    throw new IllegalArgumentException("[ERROR_NONEXHAUSTIVE_MATCH_PATTERNS]");
                }
            }
            return retType;
        }

        @Override
        public Type visit(List p, Context arg) {
            /* Code for List goes here */
            Type type = new TypeBottom();
            // Type expectedType = null;
            if (p.listexpr_.size() > 0) {
                // expectedType = p.listexpr_.get(0).accept(new ExprVisitor(), arg.newScope());
                if (!checker.ambiguousType) {
                    return new TypeList(type);
                }

                throw new IllegalArgumentException("[ERROR_AMBIGUOUS_LIST_TYPE]");
            }
            for (Expr x : p.listexpr_) {
                Type expr = x.accept(new ExprVisitor(), arg);
                type = checker.check(type, expr);
                // if (!expr.equals(expectedType)) {
                // throw new IllegalArgumentException("[ERROR_UNEXPECTED_LIST]");
                // }
            }
            return new TypeList(type);
        }

        @Override
        public Type visit(Add p, Context arg) {
            /* Code for Add goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(Subtract p, Context arg) {
            /* Code for Subtract goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(LogicOr p, Context arg) {
            /* Code for LogicOr goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(Multiply p, Context arg) {
            /* Code for Multiply goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(Divide p, Context arg) {
            /* Code for Divide goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(LogicAnd p, Context arg) {
            /* Code for LogicAnd goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(Ref p, Context arg) {
            /* Code for Ref goes here */
            Type expr = p.expr_.accept(new ExprVisitor(), arg.newScope());
            System.out.println("Ref " + expr.getClass());
            return new TypeRef(expr);
        }

        @Override
        public Type visit(Deref p, Context arg) {
            /* Code for Deref goes here */
            System.out.println("Deref");
            Type expr = p.expr_.accept(new ExprVisitor(), arg);
            // Type expr = checker.
            if (!(checker.checkNot(TypeRef.class, expr))) {
                throw new IllegalArgumentException("[ERROR_NOT_A_REFERENCE]");
            }
            return ((TypeRef) expr).type_;
        }

        @Override
        public Type visit(Application p, Context arg) {
            /* Code for Application goes here */
            System.out.println("Application");
            Type expr = p.expr_.accept(new ExprVisitor(), arg.newScope());

            if (!(checker.checkNot(TypeFun.class, expr))) {
                throw new IllegalArgumentException("[ERROR_NOT_A_FUNCTION]");
            }

            TypeFun fun = (TypeFun) expr;

            if (fun.listtype_.size() != p.listexpr_.size()) {
                throw new IllegalArgumentException("[ERROR_INCORRECT_NUMBER_OF_ARGUMENTS]");
            }
            int i = 0;
            for (Expr x : p.listexpr_) {
                System.out.println("App checking param");
                Type paramType = fun.listtype_.get(i);
                // Type exprType = x.accept(new ExprVisitor(), arg.newScope(paramType));
                Type exprType = x.accept(new ExprVisitor(), arg.newScope());
                System.out.println("App finished param");
                System.out.println(paramType.getClass() + " " + exprType.getClass());
                checker.check(paramType, exprType);
                i++;
            }
            return fun.type_;
        }

        @Override
        public Type visit(TypeApplication p, Context arg) {
            /* Code for TypeApplication goes here */
            // p.expr_.accept(new ExprVisitor<R, A>(), arg);
            // for (Type x : p.listtype_) {
            // x.accept(new TypeVisitor<R, A>(), arg);
            // }
            return null;
        }

        @Override
        public Type visit(DotRecord p, Context arg) {
            /* Code for DotRecord goes here */
            Type expr = p.expr_.accept(new ExprVisitor(), arg);

            if (!(checker.checkNot(TypeRecord.class, expr))) {
                throw new IllegalArgumentException("[ERROR_NOT_A_RECORD]");
            }
            TypeRecord record = (TypeRecord) expr;

            for (RecordFieldType i : record.listrecordfieldtype_) {
                ARecordFieldType j = (ARecordFieldType) i;
                if (j.stellaident_.equals(p.stellaident_)) {
                    return j.type_;
                }
            }
            // p.stellaident_;
            throw new IllegalArgumentException("[ERROR_UNEXPECTED_FIELD_ACCESS]");
        }

        @Override
        public Type visit(DotTuple p, Context arg) {
            /* Code for DotTuple goes here */
            Type expr = p.expr_.accept(new ExprVisitor(), arg);

            if (!(checker.checkNot(TypeTuple.class, expr))) {
                throw new IllegalArgumentException("[ERROR_NOT_A_TUPLE]");
            }

            TypeTuple tup = (TypeTuple) expr;
            if (p.integer_ > tup.listtype_.size()) {
                throw new IllegalArgumentException("[ERROR_TUPLE_INDEX_OUT_OF_BOUNDS]");
            }
            // p.integer_;
            return tup.listtype_.get(p.integer_ - 1);
        }

        @Override
        public Type visit(Tuple p, Context arg) {
            /* Code for Tuple goes here */
            ListType list = new ListType();
            for (Expr x : p.listexpr_) {
                Type expr = x.accept(new ExprVisitor(), arg);
                list.add(expr);
            }
            return new TypeTuple(list);
        }

        @Override
        public Type visit(Record p, Context arg) {
            /* Code for Record goes here */
            ListRecordFieldType list = new ListRecordFieldType();
            for (Binding x : p.listbinding_) {
                ARecordFieldType expr = x.accept(new BindingVisitor(), arg.newScope());
                list.add(expr);
            }
            return new TypeRecord(list);
        }

        @Override
        public Type visit(ConsList p, Context arg) {
            /* Code for ConsList goes here */
            Type expr1 = p.expr_1.accept(new ExprVisitor(), arg);
            Type expr2 = p.expr_2.accept(new ExprVisitor(), arg);

            if (!(checker.checkNot(TypeList.class, expr2))) {
                throw new IllegalArgumentException("[ERROR_NOT_A_LIST]");
            }

            return new TypeList(checker.check(expr1, ((TypeList) expr2).type_));
        }

        @Override
        public Type visit(Head p, Context arg) {
            /* Code for Head goes here */
            Type expr = p.expr_.accept(new ExprVisitor(), arg);
            if (!(checker.checkNot(TypeList.class, expr))) {
                throw new IllegalArgumentException("[ERROR_NOT_A_LIST]");
            }

            if (((TypeList) expr).type_ instanceof TypeBottom) {
                throw new IllegalArgumentException("[ERROR_AMBIGUOUS_LIST_TYPE]");
            }

            return ((TypeList) expr).type_;
        }

        @Override
        public Type visit(IsEmpty p, Context arg) {
            /* Code for IsEmpty goes here */
            Type expr = p.expr_.accept(new ExprVisitor(), arg);
            if (!(checker.checkNot(TypeList.class, expr))) {
                throw new IllegalArgumentException("[ERROR_NOT_A_LIST]");
            }

            if (((TypeList) expr).type_ instanceof TypeBottom) {
                throw new IllegalArgumentException("[ERROR_AMBIGUOUS_LIST_TYPE]");
            }

            return new TypeBottom();
        }

        @Override
        public Type visit(Tail p, Context arg) {
            /* Code for Tail goes here */
            Type expr = p.expr_.accept(new ExprVisitor(), arg);
            if (!(checker.checkNot(TypeList.class, expr))) {
                throw new IllegalArgumentException("[ERROR_NOT_A_LIST]");
            }

            if (((TypeList) expr).type_ instanceof TypeBottom) {
                throw new IllegalArgumentException("[ERROR_AMBIGUOUS_LIST_TYPE]");
            }

            return ((TypeList) expr);
        }

        @Override
        public Type visit(Panic p, Context arg) {
            /* Code for Panic goes here */
            // if (!checker.ambiguousType) {
            // throw new IllegalArgumentException("[ERROR_AMBIGUOUS_PANIC_TYPE]");
            // }
            return new TypePanic();
        }

        @Override
        public Type visit(Throw p, Context arg) {
            /* Code for Throw goes here */
            Type expr = p.expr_.accept(new ExprVisitor(), arg.newScope());
            if (arg.exceptionType == null) {
                throw new IllegalArgumentException("[ERROR_EXCEPTION_TYPE_NOT_DECLARED]");
            }

            checker.check(arg.exceptionType, expr);
            // if (!checker.ambiguousType) {
            // throw new IllegalArgumentException("ERROR_AMBIGUOUS_THROW_TYPE");
            // }
            return new TypeThrow();
        }

        @Override
        public Type visit(TryCatch p, Context arg) {
            /* Code for TryCatch goes here */
            Type expr1 = p.expr_1.accept(new ExprVisitor(), arg);
            if (arg.exceptionType == null) {
                throw new IllegalArgumentException("[ERROR_EXCEPTION_TYPE_NOT_DECLARED]");
            }
            // p.pattern_.accept(new PatternVisitor(), arg);
            Type expr2 = p.expr_2.accept(new ExprVisitor(), arg);
            return checker.check(expr1, expr2);
        }

        @Override
        public Type visit(TryWith p, Context arg) {
            /* Code for TryWith goes here */
            Type expr1 = p.expr_1.accept(new ExprVisitor(), arg);
            Type expr2 = p.expr_2.accept(new ExprVisitor(), arg);
            return checker.check(expr1, expr2);
        }

        @Override
        public Type visit(TryCastAs p, Context arg) {
            /* Code for TryCastAs goes here */
            // p.expr_1.accept(new ExprVisitor<R, A>(), arg);
            // p.type_.accept(new TypeVisitor<R, A>(), arg);
            // p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            // p.expr_2.accept(new ExprVisitor<R, A>(), arg);
            // p.expr_3.accept(new ExprVisitor<R, A>(), arg);
            System.out.println("TryCastAs");
            return null;
        }

        @Override
        public Type visit(Inl p, Context arg) {
            /* Code for Inl goes here */
            System.out.println("Inl");
            // if (!checker.ambiguousType) {
            // throw new IllegalArgumentException("[ERROR_AMBIGUOUS_SUM_TYPE]");
            // }
            return new TypeSum(p.expr_.accept(new ExprVisitor(), arg.newScope()), new TypeBottom());
        }

        @Override
        public Type visit(Inr p, Context arg) {
            /* Code for Inr goes here */
            System.out.println("Inr");
            // if (!checker.ambiguousType) {
            // throw new IllegalArgumentException("[ERROR_AMBIGUOUS_SUM_TYPE]");
            // }
            return new TypeSum(new TypeBottom(), p.expr_.accept(new ExprVisitor(), arg.newScope()));
        }

        @Override
        public Type visit(Succ p, Context arg) {
            /* Code for Succ goes here */
            System.out.println("Succ\n");
            Type exprType = p.expr_.accept(new ExprVisitor(), arg.newScope());
            checker.check(new TypeNat(), exprType);
            return new TypeNat();
        }

        @Override
        public Type visit(LogicNot p, Context arg) {
            /* Code for LogicNot goes here */
            // p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(Pred p, Context arg) {
            /* Code for Pred goes here */
            // p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(IsZero p, Context arg) {
            /* Code for IsZero goes here */
            Type exprType = p.expr_.accept(new ExprVisitor(), arg);
            checker.check(new TypeNat(), exprType);
            return new TypeBool();
        }

        @Override
        public Type visit(Fix p, Context arg) {
            /* Code for Fix goes here */
            Type expr = p.expr_.accept(new ExprVisitor(), arg);
            if (!(checker.checkNot(TypeFun.class, expr))) {
                throw new IllegalArgumentException("[ERROR_NOT_A_FUNCTION]");
            }
            TypeFun fun = (TypeFun) expr;
            return checker.check(fun.listtype_.get(0), fun.type_);
        }

        @Override
        public Type visit(NatRec p, Context arg) {
            /* Code for NatRec goes here */
            Type expr1 = p.expr_1.accept(new ExprVisitor(), arg);
            Type expr2 = p.expr_2.accept(new ExprVisitor(), arg);
            Type expr3 = p.expr_3.accept(new ExprVisitor(), arg);

            checker.check(new TypeNat(), expr1);

            if (!(TypeFun.class.isInstance(expr3))) {
                System.out.println("epxr11");
                throw new IllegalArgumentException("[ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION]");
            }
            TypeFun expr3Fun = (TypeFun) expr3;
            if (expr3Fun.listtype_.size() != 1) {
                checker.check(new TypeNat(), expr3Fun.listtype_.get(0));
            }

            if (!(TypeFun.class.isInstance(expr3Fun))) {
                System.out.println("expr2");
                throw new IllegalArgumentException("[ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION]");
            }
            try {
                System.out.println("here");
                TypeFun expr3FunRet = (TypeFun) expr3Fun.type_;
                if (expr3FunRet.listtype_.size() != 1) {
                    checker.check(expr2, expr3FunRet.listtype_.get(0));
                }

                checker.check(expr2, expr3FunRet.type_);
                System.out.println("there");
            } catch (Exception e) {
                throw new IllegalArgumentException("[ERROR_UNEXPECTED_TYPE_FOR_EXPRESSION]");
            }

            return expr2;
        }

        @Override
        public Type visit(Fold p, Context arg) {
            /* Code for Fold goes here */
            // p.type_.accept(new TypeVisitor<R, A>(), arg);
            // p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(Unfold p, Context arg) {
            /* Code for Unfold goes here */
            // p.type_.accept(new TypeVisitor<R, A>(), arg);
            // p.expr_.accept(new ExprVisitor<R, A>(), arg);
            return null;
        }

        @Override
        public Type visit(ConstTrue p, Context arg) {
            /* Code for ConstTrue goes here */
            return new TypeBool();
        }

        @Override
        public Type visit(ConstFalse p, Context arg) {
            /* Code for ConstFalse goes here */
            return new TypeBool();
        }

        @Override
        public Type visit(ConstUnit p, Context arg) {
            /* Code for ConstUnit goes here */
            return new TypeUnit();
        }

        @Override
        public Type visit(ConstInt p, Context arg) {
            /* Code for ConstInt goes here */
            // p.integer_;
            System.out.println("ConstInt\n");
            return new TypeNat();
        }

        @Override
        public Type visit(ConstMemory p, Context arg) {
            /* Code for ConstMemory goes here */
            // p.memoryaddress_;
            return new TypeRef(new TypeBottom());
        }

        @Override
        public Type visit(Var p, Context arg) {
            /* Code for Var goes here */
            // p.stellaident_;
            System.out.println("Var " + p.stellaident_ + " " + p.line_num);
            if (!arg.variables.containsKey(p.stellaident_)) {
                throw new IllegalArgumentException("[ERROR_UNDEFINED_VARIABLE]");
            }
            return arg.variables.get(p.stellaident_);
        }
    }

    public class PatternBindingVisitor implements PatternBinding.Visitor<Void, Context> {

        @Override
        public Void visit(APatternBinding p, Context arg) {
            /* Code for APatternBinding goes here */
            // p.pattern_.accept(new PatternVisitor<R, A>(), arg);
            PatternVar pattern = (PatternVar) p.pattern_;
            Type expr = p.expr_.accept(new ExprVisitor(), arg.newScope());
            System.out.println("APatternBinding " + pattern.stellaident_ + " " + expr.getClass());

            if (expr instanceof TypeRef exprTypeRef && exprTypeRef.type_ instanceof TypeBottom) {
                throw new IllegalArgumentException("[ERROR_AMBIGUOUS_REFERENCE_TYPE]");
            }

            arg.variables.put(pattern.stellaident_, expr);
            return null;
        }
    }

    public class VariantFieldTypeVisitor<R, A> implements VariantFieldType.Visitor<R, A> {

        @Override
        public R visit(AVariantFieldType p, A arg) {
            /* Code for AVariantFieldType goes here */
            // p.stellaident_;
            // p.optionaltyping_.accept(new OptionalTypingVisitor<R, A>(), arg);
            return null;
        }
    }

    public class RecordFieldTypeVisitor implements RecordFieldType.Visitor<ARecordFieldType, Context> {

        @Override
        public ARecordFieldType visit(ARecordFieldType p, Context arg) {
            /* Code for ARecordFieldType goes here */
            // p.stellaident_;
            // p.type_.accept(new TypeVisitor(), arg);
            return new ARecordFieldType(p.stellaident_, p.type_);
        }
    }

    public class TypingVisitor<R, A> implements Typing.Visitor<R, A> {

        @Override
        public R visit(ATyping p, A arg) {
            /* Code for ATyping goes here */
            // p.expr_.accept(new ExprVisitor<R, A>(), arg);
            // p.type_.accept(new TypeVisitor<R, A>(), arg);
            return null;
        }
    }
}
